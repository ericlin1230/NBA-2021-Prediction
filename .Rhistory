kable(round(summary(fact.mod)$coefficients, 2))
kable(round(2*confint.lm(fact.mod), 2))
run1 <- c(13, 16,12,15,6,4,9,11)
run2 <- c(3, 2, 10,5,7,14,8,1)
gpu <- c(-1,1,-1,1,-1,1,-1,1)
cpu <- c(-1,-1,1,1,-1,-1,1,1)
imgq <- c(-1,-1,-1,-1,1,1,1,1)
fps1 <- c(93.7,94.2,97.7,98.9,76.8,79.8,77.0,81.0)
fps2 <- c(93.2,93.8,97.3,97.8,76.5,79.9,76.0,80.5)
data2 <- data.frame(run1, run2, gpu, cpu, imgq, fps1, fps2)
data2$diff_fps <- data2$fps2 - data2$fps1
pooled_sigma <- sum((data2$diff_fps^2)/2)/8
var_effect <- 0.25*pooled_sigma
t_95 <- qt(p=1-0.025, df =8)
effect_diff <- sqrt(var_effect)*t_95
colnames(data2) <- c("Run #1", "Run #2", "GPU", "CPU", "Quality", "FPS1", "FPS2", "FPS Diff")
kable(data2, caption = "The table for the 2^3 design for the duplicated runs")
kable(cube_data)
main_GPU <- ((93.45 + 97.50 + 76.65 + 76.50)/4) - ((94.00 + 98.35 + 79.85 + 80.75)/4)
main_CPU <- ((93.45 + 94.00 + 76.65 + 79.85)/4) - ((97.50 + 98.35 + 76.50 + 80.75)/4)
main_IMG <- ((93.45 + 94.00 + 97.50 + 98.35)/4) - ((76.65 + 79.85 + 76.50 + 80.75)/4)
Int_GQ <- ((((80.75+79.85)/2) - ((76.50+76.65)/2))-(((98.35+94.00)/2) - ((93.45+97.50)/2)))/2
Int_GC <- ((((80.75+98.35)/2) - ((76.50+97.50)/2))-(((94.00+79.85)/2) - ((76.65+93.45)/2)))/2
Int_CQ <- ((((80.75+76.50)/2) - ((76.65+79.85)/2))-(((98.35+97.50)/2) - ((94.00+93.45)/2)))/2
Int_GCQ <- ((((cube_data$FPS[8]-cube_data$FPS[7]) - (cube_data$FPS[6]-cube_data$FPS[5]))/2)
- (((cube_data$FPS[4]-cube_data$FPS[3]) - (cube_data$FPS[2]-cube_data$FPS[1]))/2))/2
interactions <- c("G", "C", "Q", "GQ", "GC", "CQ", "GCQ")
lower_bound <- c(main_GPU-effect_diff, main_CPU-effect_diff,
main_IMG-effect_diff, Int_GQ-effect_diff,
Int_GC-effect_diff, Int_CQ-effect_diff, Int_GCQ-effect_diff)
upper_bound <- c(main_GPU+effect_diff, main_CPU+effect_diff,
main_IMG+effect_diff, Int_GQ+effect_diff,
Int_GC+effect_diff, Int_CQ+effect_diff, Int_GCQ+effect_diff)
com <- data.frame(lower_bound, upper_bound)
com <- apply(com,1,function(x){
paste0("(",paste(x, collapse=", "),")")
})
com <- data.frame(interactions, com)
colnames(com) <- c("Effects", "95% Confidence Interval")
kable(com)
kable(cube_data, caption = "The table for the results of the runs averaged")
main_GPU <- ((93.45 + 97.50 + 76.65 + 76.50)/4) - ((94.00 + 98.35 + 79.85 + 80.75)/4)
main_CPU <- ((93.45 + 94.00 + 76.65 + 79.85)/4) - ((97.50 + 98.35 + 76.50 + 80.75)/4)
main_IMG <- ((93.45 + 94.00 + 97.50 + 98.35)/4) - ((76.65 + 79.85 + 76.50 + 80.75)/4)
Int_GQ <- ((((80.75+79.85)/2) - ((76.50+76.65)/2))-(((98.35+94.00)/2) - ((93.45+97.50)/2)))/2
Int_GC <- ((((80.75+98.35)/2) - ((76.50+97.50)/2))-(((94.00+79.85)/2) - ((76.65+93.45)/2)))/2
Int_CQ <- ((((80.75+76.50)/2) - ((76.65+79.85)/2))-(((98.35+97.50)/2) - ((94.00+93.45)/2)))/2
Int_GCQ <- ((((cube_data$FPS[8]-cube_data$FPS[7]) - (cube_data$FPS[6]-cube_data$FPS[5]))/2)
- (((cube_data$FPS[4]-cube_data$FPS[3]) - (cube_data$FPS[2]-cube_data$FPS[1]))/2))/2
interactions <- c("G", "C", "Q", "GQ", "GC", "CQ", "GCQ")
lower_bound <- c(main_GPU-effect_diff, main_CPU-effect_diff,
main_IMG-effect_diff, Int_GQ-effect_diff,
Int_GC-effect_diff, Int_CQ-effect_diff, Int_GCQ-effect_diff)
upper_bound <- c(main_GPU+effect_diff, main_CPU+effect_diff,
main_IMG+effect_diff, Int_GQ+effect_diff,
Int_GC+effect_diff, Int_CQ+effect_diff, Int_GCQ+effect_diff)
com <- data.frame(lower_bound, upper_bound)
com <- apply(com,1,function(x){
paste0("(",paste(x, collapse=", "),")")
})
com <- data.frame(interactions, com)
colnames(com) <- c("Effects", "95% Confidence Interval")
kable(com, caption = "Table of the effects and their confidence interval")
interaction.plot(cube_data$GPU, cube_data$Quality, cube_data$FPS, type="l", xlab="GPU", ylab="FPS", trace.label = "Game Quality", main = "The interaction plot of GPU clock speed by game quality")
interaction.plot(cube_data$GPU, cube_data$Quality, cube_data$FPS, type="l",
xlab="GPU", ylab="FPS", trace.label = "Game Quality",
main = "The interaction plot of GPU clock speed by game quality")
interaction.plot(cube_data$GPU, cube_data$CPU, cube_data$FPS, type="l",
xlab="GPU", ylab="FPS", trace.label = "CPU",
main = "The interaction plot of GPU clock speed by CPu clock speed")
interaction.plot(cube_data$CPU, cube_data$Quality, cube_data$FPS, type="l",
xlab="CPU", ylab="FPS", trace.label = "Game Quality",
main = "The interaction plot of CPU clock speed by game quality")
fact.mod <- lm(fps~gpu*cpu*imgq, data = data1)
kable(round(summary(fact.mod)$coefficients, 2), caption = "Table of the linear model estimates for the effects")
kable(round(2*confint.lm(fact.mod), 2), caption = "Table of the confidence interval for the effects from the linear model")
kable(cube_data, caption = "The table for the results of the runs averaged")
main_GPU <- ((93.45 + 97.50 + 76.65 + 76.50)/4) - ((94.00 + 98.35 + 79.85 + 80.75)/4)
main_CPU <- ((93.45 + 94.00 + 76.65 + 79.85)/4) - ((97.50 + 98.35 + 76.50 + 80.75)/4)
main_IMG <- ((93.45 + 94.00 + 97.50 + 98.35)/4) - ((76.65 + 79.85 + 76.50 + 80.75)/4)
Int_GQ <- ((((80.75+79.85)/2) - ((76.50+76.65)/2))-(((98.35+94.00)/2) - ((93.45+97.50)/2)))/2
Int_GC <- ((((80.75+98.35)/2) - ((76.50+97.50)/2))-(((94.00+79.85)/2) - ((76.65+93.45)/2)))/2
Int_CQ <- ((((80.75+76.50)/2) - ((76.65+79.85)/2))-(((98.35+97.50)/2) - ((94.00+93.45)/2)))/2
Int_GCQ <- ((((cube_data$FPS[8]-cube_data$FPS[7]) - (cube_data$FPS[6]-cube_data$FPS[5]))/2)
- (((cube_data$FPS[4]-cube_data$FPS[3]) - (cube_data$FPS[2]-cube_data$FPS[1]))/2))/2
interactions <- c("G", "C", "Q", "GQ", "GC", "CQ", "GCQ")
lower_bound <- c(main_GPU-effect_diff, main_CPU-effect_diff,
main_IMG-effect_diff, Int_GQ-effect_diff,
Int_GC-effect_diff, Int_CQ-effect_diff, Int_GCQ-effect_diff)
upper_bound <- c(main_GPU+effect_diff, main_CPU+effect_diff,
main_IMG+effect_diff, Int_GQ+effect_diff,
Int_GC+effect_diff, Int_CQ+effect_diff, Int_GCQ+effect_diff)
com <- data.frame(lower_bound, upper_bound)
com <- apply(com,1,function(x){
paste0("(",paste(x, collapse=", "),")")
})
com <- data.frame(interactions, com)
colnames(com) <- c("Effects", "95% Confidence Interval")
kable(com, caption = "Table of the effects and their confidence interval")
interaction.plot(cube_data$GPU, cube_data$Quality, cube_data$FPS, type="l",
xlab="GPU", ylab="FPS", trace.label = "Game Quality",
main = "The interaction plot of GPU clock speed by game quality")
set.seed(1003982862)
library(cmdstanr)
library(tidyverse)
library(tidybayes)
library(posterior)
library(dplyr)
library(bayesplot)
knitr::opts_chunk$set(echo = TRUE)
dat <- read.csv("Verreauxs.accel.txt", sep = "\t")
set.seed(1003982862)
library(cmdstanr)
library(tidyverse)
library(tidybayes)
library(posterior)
library(dplyr)
library(bayesplot)
knitr::opts_chunk$set(echo = TRUE)
dat <- read.csv("Verreauxs.accel.txt", sep = "\t")
set.seed(1003982862)
rpois(100, 47)
mean(dat$wind_speed)
mean(dat$saws_temp)
set.seed(1003982862)
library(cmdstanr)
library(tidyverse)
library(tidybayes)
library(posterior)
library(dplyr)
library(loo)
library(bayesplot)
knitr::opts_chunk$set(echo = TRUE)
dat <- read.csv("Verreauxs.accel.txt", sep = "\t")
set.seed(1003982862)
N = dat$msa %>% length()
mus = abs(rnorm(2, 2, 0.5))
mus = sort(mus)
sigma1 = abs(rnorm(1,0,0.8))
sigma2 = abs(rnorm(1,0,0.8))
stateZ = rbinom(N, 1, 0.35) + 1 # Makes the state either 1 or 2
gen_res = rep(NA,N)
for(i in 1:N){
if(stateZ[i] == 1){
gen_res[i] = abs(log(abs(rnorm(1, mus[1], sigma1))))
}else if(stateZ[i] == 2){
gen_res[i] = abs(log(abs(rnorm(1, mus[2], sigma2))))
}
}
mod3 <- cmdstan_model("task3.stan")
mod3 <- cmdstan_model("task3.stan")
mod3$print()
task3_dat <- list(N = dat$msa %>% length(),
y = gen_res,
only_prior = 0,
stateZ = stateZ)
fit5 <- mod3$sample(task3_dat, parallel_chains = 4, refresh = 0)
mcmc_hist(fit5$draws(c("log_lik[1]","log_lik[100]","log_lik[200]","log_lik[300]","log_lik[400]","log_lik[500]","log_lik[600]","log_lik[700]","log_lik[800]","log_lik[900]","log_lik[1000]"))) + ggtitle("Plot of prior mcmc histograms for task 1")
set.seed(1003982862)
N = dat$msa %>% length()
mus = abs(rnorm(3, 2, 0.5))
mus = sort(mus)
sigma1 = abs(rnorm(1,0,0.8))
sigma2 = abs(rnorm(1,0,0.8))
sigma3 = abs(rnorm(1,0,0.8))
stateZ = rbinom(N, 1, 0.35) + 1 # Makes the state either 1 or 2
gen_res2 = rep(NA,N)
for(i in 1:N){
if(stateZ[i] == 1){
gen_res2[i] = abs(log(abs(rnorm(1, mus[1], sigma1))))
}else if(stateZ[i] == 2){
gen_res2[i] = abs(log(abs(rnorm(1, mus[2], sigma2))))
}else if(stateZ[i] == 3){
gen_res2[i] = abs(log(abs(rnorm(1, mus[3], sigma3))))
}
}
task3_dat2 <- list(N = dat$msa %>% length(),
y = gen_res2,
only_prior = 0,
stateZ = stateZ)
fit6 <- mod3$sample(task3_dat, parallel_chains = 4, refresh = 0)
mcmc_hist(fit6$draws(c("log_lik[1]","log_lik[100]","log_lik[200]","log_lik[300]","log_lik[400]","log_lik[500]","log_lik[600]","log_lik[700]","log_lik[800]","log_lik[900]","log_lik[1000]"))) + ggtitle("Plot of posterior mcmc histograms for 2 components")
yrep = fit6$draws() %>% reshape2::melt() %>% filter(str_detect(variable, "log_lik")) %>%
extract(col = variable, into = "ind",
regex = "log_lik\\[([0-9]*)\\]",
convert = TRUE) %>%
pivot_wider(id_cols = c("chain","iteration"),
names_from = "ind") %>%
select(-c("chain", "iteration")) %>% as.matrix
ppc_stat(dat$msa,yrep, stat = "min") + ggtitle("Posterior predictive plot for 2 components")
yrep = fit7$draws() %>% reshape2::melt() %>% filter(str_detect(variable, "log_lik")) %>%
extract(col = variable, into = "ind",
regex = "log_lik\\[([0-9]*)\\]",
convert = TRUE) %>%
pivot_wider(id_cols = c("chain","iteration"),
names_from = "ind") %>%
select(-c("chain", "iteration")) %>% as.matrix
yrep = fit5$draws() %>% reshape2::melt() %>% filter(str_detect(variable, "log_lik")) %>%
extract(col = variable, into = "ind",
regex = "log_lik\\[([0-9]*)\\]",
convert = TRUE) %>%
pivot_wider(id_cols = c("chain","iteration"),
names_from = "ind") %>%
select(-c("chain", "iteration")) %>% as.matrix
ppc_stat(gen_res,yrep, stat = "min") + ggtitle("Posterior predictive plot for 2 components")
yrep = fit6$draws() %>% reshape2::melt() %>% filter(str_detect(variable, "log_lik")) %>%
extract(col = variable, into = "ind",
regex = "log_lik\\[([0-9]*)\\]",
convert = TRUE) %>%
pivot_wider(id_cols = c("chain","iteration"),
names_from = "ind") %>%
select(-c("chain", "iteration")) %>% as.matrix
ppc_stat(gen_res2,yrep, stat = "min") + ggtitle("Posterior predictive plot for 3 components")
mcmc_hist(fit5$draws(c("log_lik[1]","log_lik[100]","log_lik[200]","log_lik[300]","log_lik[400]","log_lik[500]","log_lik[600]","log_lik[700]","log_lik[800]","log_lik[900]","log_lik[1000]"))) + ggtitle("Plot of posterior mcmc histograms for 2 components")
mcmc_hist(fit6$draws(c("log_lik[1]","log_lik[100]","log_lik[200]","log_lik[300]","log_lik[400]","log_lik[500]","log_lik[600]","log_lik[700]","log_lik[800]","log_lik[900]","log_lik[1000]"))) + ggtitle("Plot of posterior mcmc histograms for 3 components")
# read in the data
black_saber_current_employees <- read_csv("data/black-saber-current-employees.csv")
library(tidyverse)
# this should supress all code and messages
knitr::opts_chunk$set(include=FALSE)
# read in the data
black_saber_current_employees <- read_csv("data/black-saber-current-employees.csv")
set.seed(1003982862)
library(cmdstanr)
library(tidyverse)
library(tidybayes)
library(posterior)
library(dplyr)
library(loo)
library(bayesplot)
knitr::opts_chunk$set(echo = TRUE)
dat <- read.csv("Verreauxs.accel.txt", sep = "\t")
set.seed(1003982862)
N = dat$msa %>% length()
mus = abs(rnorm(2, 2, 0.5))
mus = sort(mus)
sigma1 = abs(rnorm(1,0,0.8))
sigma2 = abs(rnorm(1,0,0.8))
stateZ = rbinom(N, 1, 0.35) + 1 # Makes the state either 1 or 2
gen_res = rep(NA,N)
for(i in 1:N){
if(stateZ[i] == 1){
gen_res[i] = abs(log(abs(rnorm(1, mus[1], sigma1))))
}else if(stateZ[i] == 2){
gen_res[i] = abs(log(abs(rnorm(1, mus[2], sigma2))))
}
}
mod <- cmdstan_model("asdf.stan")
mod$print()
task1_dat2 <- list(N = dat$msa %>% length(),
y = gen_res,
mu = mus,
sigma1=sigma1,
sigma2=sigma2
)
fit <- mod$sample(task1_dat2, parallel_chains = 4, refresh = 0)
mcmc_hist(fit$draws(c("log_lik[1]","log_lik[100]","log_lik[200]","log_lik[300]","log_lik[400]","log_lik[500]","log_lik[600]","log_lik[700]","log_lik[800]","log_lik[900]","log_lik[1000]"))) + ggtitle("Plot of prior mcmc histograms for task 1")
setwd("D:/Project/nba ai")
library(dplyr)
library(tidyverse)
champs <- read.csv("champs.csv")
library(dplyr)
library(tidyverse)
champs <- read.csv("champs.csv")
View(champs)
champs %>% filter(Lg == 'NBA')
nba_champs <- champs %>% filter(Lg == 'NBA')
View(nba_champs)
write.csv(nba_champs, "filtered_nba_champs.csv")
write.csv(nba_champs, "filtered_nba_champs.csv", row.names = FALSE)
team_totals <- read.csv("Team Totals.csv")
View(team_totals)
nba_champs[0]
nba_champs[0,3]
nba_champs$Champion[0]
nba_champs$Champion[0,]
nba_champs$Champion[0]
nba_champs
nba_champs$Champion
nba_champs$Champion[1]
unique(team_totals$season)
count(unique(team_totals$season))
a <- unique(team_totals$season)
length(a)
for(i in 1:75){
if(i==1){
team_totals$champs <- 0
}
}
team_totals$champs <- ifelse(team_totals$season==nba_champs$Year & team_totals$team==nba_champs$Champion, 1, 0)
team_nba  <- team_totals %>% filter(lg == 'NBA')
View(team_nba)
for(i in 1:1615){
indx = 2021 - team_nba$season[i]
if(indx >0){
if(nba_champs$Champion[indx] ==team_nba$team){
team_nba$champs[i]=1
}
}
}
warnings()
for(i in 1:1615){
indx = 2021 - team_nba$season[i]
if(indx >0){
if(nba_champs$Champion[indx] ==team_nba$team[i]){
team_nba$champs[i] = 1
}
}
}
sum(team_nba$champs)
team_nba  <- team_totals %>% filter(season>=1950)
team_nba  <- team_totals %>% filter(season>=1980)
for(i in 1:1206){
indx = 2021 - team_nba$season[i]
if(indx >0){
if(nba_champs$Champion[indx] ==team_nba$team[i]){
team_nba$champs[i] = 1
}
}
}
sum(team_nba$champs)
write.csv(team_nba, "nba_champs_comb.csv", row.names = FALSE)
source('D:/Project/nba ai/data clean.R')
team_sum <- read.csv("Team Summaries.csv")
temp <- left_join(team_nba, team_sum)
View(temp)
temp$wpct <- temp$w/(temp$w+temp$l)
temp$wpct <- temp$w/(temp$w+temp$l)
View(temp)
temp$wpct
temp
write.csv(temp, "nba_champs_comb2.csv", row.names = FALSE)
View(team_sum)
library(dplyr)
library(tidyverse)
champs <- read.csv("champs.csv")
nba_champs <- champs %>% filter(Lg == 'NBA')
write.csv(nba_champs, "filtered_nba_champs.csv", row.names = FALSE)
team_totals <- read.csv("Team Totals.csv")
for(i in 1:75){
if(i==1){
team_totals$champs <- 0
}
else{
if(team_totals$season == 2022 - i){
}
}
}
team_nba  <- team_totals %>% filter(lg == 'NBA')
for(i in 1:1206){
indx = 2021 - team_nba$season[i]
if(indx >0){
if(nba_champs$Champion[indx] ==team_nba$team[i]){
team_nba$champs[i] = 1
}
}
}
team_nba  <- team_totals %>% filter(season>=1980)
write.csv(team_nba, "nba_champs_comb.csv", row.names = FALSE)
sum(team_nba$champs)
team_sum <- read.csv("Team Summaries.csv")
temp <- left_join(team_nba, team_sum)
temp$wpct <- temp$w/(temp$w+temp$l)
write.csv(temp, "nba_champs_comb2.csv", row.names = FALSE)
library(dplyr)
library(tidyverse)
champs <- read.csv("champs.csv")
nba_champs <- champs %>% filter(Lg == 'NBA')
write.csv(nba_champs, "filtered_nba_champs.csv", row.names = FALSE)
team_totals <- read.csv("Team Totals.csv")
for(i in 1:75){
if(i==1){
team_totals$champs <- 0
}
else{
if(team_totals$season == 2022 - i){
}
}
}
team_nba  <- team_totals %>% filter(lg == 'NBA')
for(i in 1:1206){
indx = 2021 - team_nba$season[i]
if(indx >0){
if(nba_champs$Champion[indx] ==team_nba$team[i]){
team_nba$champs[i] = 1
}
}
}
team_nba  <- team_totals %>% filter(season>=1980)
write.csv(team_nba, "nba_champs_comb.csv", row.names = FALSE)
sum(team_nba$champs)
team_sum <- read.csv("Team Summaries.csv")
temp <- left_join(team_nba, team_sum)
temp$wpct <- temp$w/(temp$w+temp$l)
write.csv(temp, "nba_champs_comb2.csv", row.names = FALSE)
View(team_totals)
View(team_sum)
View(champs)
View(team_nba)
View(team_totals)
View(temp)
temp <- left_join(team_nba, team_sum, by=c("season", "team"))
View(temp)
temp$wpct <- temp$w/(temp$w+temp$l)
write.csv(temp, "nba_champs_comb2.csv", row.names = FALSE)
source('D:/Project/nba ai/data clean.R')
avg_removed <- temp[temp$team!= "League Average",]
write.csv(avg_removed, "nba_champs_comb3.csv", row.names = FALSE)
View(avg_removed)
for(i in 1:1206){
indx = 2021 - team_nba$season[i]
if(indx >0){
if(nba_champs$Champion[indx] ==team_nba$team[i]){
team_nba$champs[i] = 1
}
}
}
View(temp)
team_sum <- read.csv("Team Summaries.csv")
temp <- left_join(team_nba, team_sum, by=c("season", "team"))
temp$wpct <- temp$w/(temp$w+temp$l)
avg_removed <- temp[temp$team!= "League Average",]
write.csv(avg_removed, "nba_champs_comb3.csv", row.names = FALSE)
source('D:/Project/nba ai/data clean.R')
wout_champ <- read.csv('nba_champs_train')
library(dplyr)
library(tidyverse)
for(i in 1:75){
if(i==1){
wout_champ$champs <- 0
}
else{
if(wout_champ$season == 2022 - i){
}
}
}
wout_champ <- read.csv('nba_champs_train.csv')
team_totals <- read.csv("Team Totals.csv")
for(i in 1:75){
if(i==1){
wout_champ$champs <- 0
}
else{
if(wout_champ$season == 2022 - i){
}
}
}
for(i in 1:1206){
indx = 2021 - team_nba$season[i]
if(indx >0){
if(nba_champs$Champion[indx] ==team_nba$team[i]){
team_nba$champs[i] = 1
}
}
}
team_nba  <- team_totals %>% filter(season>=1980)
write.csv(team_nba, "nba_champs_comb1.csv", row.names = FALSE)
champs <- read.csv("champs.csv")
library(dplyr)
library(tidyverse)
champs <- read.csv("champs.csv")
nba_champs <- champs %>% filter(Lg == 'NBA')
wout_champ <- read.csv('nba_champs_train.csv')
team_totals <- read.csv("Team Totals.csv")
for(i in 1:75){
if(i==1){
wout_champ$champs <- 0
}
else{
if(wout_champ$season == 2022 - i){
}
}
}
warnings()
View(champs)
View(nba_champs)
team_nba  <- wout_champ %>% filter(lg == 'NBA')
for(i in 1:1206){
indx = 2021 - wout_champ$season[i]
if(indx >0){
if(nba_champs$Champion[indx] ==wout_champ$team[i]){
wout_champ$champs[i] = 1
}
}
}
View(wout_champ)
for(i in 1:1206){
indx = 2021 - wout_champ$season[i]
if(indx >0){
if(nba_champs$Champion[indx] ==wout_champ$team[i]){
wout_champ$champs[i] = 1
}
else{
wout_champ$champs[i] = 0
}
}
}
for(i in 1:1134){
indx = 2021 - wout_champ$season[i]
if(indx >0){
if(nba_champs$Champion[indx] ==wout_champ$team[i]){
wout_champ$champs[i] = 1
}
else{
wout_champ$champs[i] = 0
}
}
}
View(wout_champ)
wout_champ$champs
write.csv(wout_champ$champs, "nba_champs_comb1.csv", row.names = FALSE)
write.csv(wout_champ, "nba_champs_comb1.csv", row.names = FALSE)
